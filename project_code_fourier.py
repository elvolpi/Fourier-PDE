# -*- coding: utf-8 -*-
"""

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BuR321XKz9XTatLLN6z1nl1UPdtMKZM7
"""



"""# Project: Python Code For Heat IBVP

Nestor Iwanojko, Elena Volpi
---
**IBVP:**
$$\begin{cases}
\frac{\partial u}{\partial t}=\frac{\partial^2 u}{\partial x^2} \\
u(0,t)=0 \\
u(1,t)=0 \\
u(x,0)=u_0(x)
\end{cases}$$

**First IC:**
$u_0(x)=\sin(n\pi)$

Code for a solution with the given IC is provided below. The analytic solution is $u(x,t)=e^{-\pi^2t}\sin(\pi x)$. A pliot of this solution and the estimated solution is generated by the code.
"""

import numpy as np
import matplotlib.pyplot as plt
import time
import math

t0 = time.time()
a = 0
b = 1
N = 50                      # increase this value to improve the resolution

h = (b-a)/N
x = np.linspace(a, b, N)     # subdivide [a,b] as indicated above
y = np.sin(np.pi*x)

#plt.plot(x,y)

c = 0
d = 0.5
M = 10100
k = (d-c)/M
var = k/(h**2)

u = np.zeros( (N, M) )         # here is the temperature function
#print( u )                     # this will work best if N, M are small

u[:,0] = np.sin(np.pi*x)
#print(u)                       # this will work best if N, M are small

for j in range(M-1):
 # for i in range(1,N-1): 
    u[1:N-1, j+1] = u[1:N-1,j]+var*(u[2:N,j] + u[0:N-2,j]-2*u[1:N-1,j])

print(u)

t = np.linspace(c,d,M)
T, X = np.meshgrid(t, x)
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.plot_surface(T, X, u,cmap='coolwarm')
ax.set_xlabel('t')
ax.set_ylabel('x')
ax.set_zlabel('u');

uf = math.e**(-(np.pi**2)*T)*np.sin(np.pi*X)
ax.plot_wireframe(T, X, uf, color='black')





tf = time.time()
print('the time this took is', tf-t0)

"""**Second IC:**
$u_0(x)=x-x^2$

Code for a solution with the given IC is provided below. The analytic solution will be a Fourier series with the Fourier coefficients computed in mathematica:
 $$u(x,t)=\sum_{n=1}^\infty b_n e^{-(n\pi)^2t} \sin(n\pi x)$$
 $$b_n=\int_0^1(x-x^2)\sin(n\pi x)dx=\frac{2(2-2\cos(n\pi)-n\pi\sin(n\pi))}{n^3\pi^3}.$$ 
A plot of this solution and the estimated solution is generated by the code. We take the first 10 terms of the Fourier series solution.
"""

import numpy as np
import matplotlib.pyplot as plt
import time
import math

t0 = time.time()
a = 0
b = 1
N = 100                     # increase this value to improve the resolution

h = (b-a)/N
x = np.linspace(a, b, N)     # subdivide [a,b] as indicated above
y = x-x**2                   # any other function will do!


#plt.plot(x,y)

c = 0
d = 0.5
M = 10100
k = (d-c)/M
var = k/(h**2)

u = np.zeros( (N, M) )         # here is the temperature function
#print( u )                     # this will work best if N, M are small

u[:,0] = x - x**2

#print(u)                       # this will work best if N, M are small

for j in range(M-1):
   
    u[1:N-1,j+1] = u[1:N-1,j]+var*(u[2:N,j] + u[0:N-2,j]-2*u[1:N-1,j])

#print(u)

t = np.linspace(c,d,M)
T, X = np.meshgrid(t, x)
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.plot_surface(T, X, u,cmap='coolwarm')
ax.set_xlabel('t')
ax.set_ylabel('x')
ax.set_zlabel('u');

#uf2 = 0
#for n in range(1,10+1):
 # uf2 += math.e**(-(n*np.pi)^2*T)*np.sin(n*np.pi*X)*((2*(2-2*np.cos(n*np.pi)-n*np.pi*np.sin(n*np.pi))/n**3*np.pi**3))

#ax.plot_wireframe(T, X, uf2, color='black')



import numpy as np
import matplotlib.pyplot as plt
import time
import math

t0 = time.time()
a = 0
b = 1
N = 100                     # increase this value to improve the resolution

h = (b-a)/N
x = np.linspace(a, b, N)     # subdivide [a,b] as indicated above
y = x-x**2                   # any other function will do!


#plt.plot(x,y)

c = 0
d = 0.5
M = 10100
k = (d-c)/M
var = k/(h**2)

u = np.zeros( (N, M) )         # here is the temperature function
#print( u )                     # this will work best if N, M are small

u[:,0] = x - x**2

#print(u)                       # this will work best if N, M are small

for j in range(M-1):
   
    u[1:N-1,2:M] = u[1:N-1,1:M-1]+var*(u[2:N,1:M-1] + u[0:N-2,1:M-1]-2*u[1:N-1,1:M-1])

print(u)

t = np.linspace(c,d,M)
T, X = np.meshgrid(t, x)
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.plot_surface(T, X, u,cmap='coolwarm')
ax.set_xlabel('t')
ax.set_ylabel('x')
ax.set_zlabel('u');

#uf2 = 0
#for n in range(1,10+1):
 # uf2 += math.e**(-(n*np.pi)^2*T)*np.sin(n*np.pi*X)*((2*(2-2*np.cos(n*np.pi)-n*np.pi*np.sin(n*np.pi))/n**3*np.pi**3))

#ax.plot_wireframe(T, X, uf2, color='black')
